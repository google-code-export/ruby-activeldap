# 推敲中

<wiki:comment>
  Introduction
</wiki:comment>
= はじめに =

<wiki:comment>
  ActiveLdap is a novel way of interacting with LDAP. Most interaction
  with LDAP is done using clunky LDIFs, web interfaces, or with painful APIs
  that required a thick reference manual nearby. ActiveLdap aims to fix
  that. Inspired by ActiveRecord, ActiveLdap provides an object
  oriented interface to LDAP entries. 
</wiki:comment>
ActiveLdap は LDAP を操作する今までにない方法です。大半のLDAP操作は難しい
LDIFを扱うか、ウェブインターフェースを利用するか、説明の省かれたリファレンスマ
ニュアルを参照しながら、難解なAPIを利用しなければなりませんでした。

ActiveLdap はこの解決を目指します。ActiveRecord によって着想した ActiveLdap 
は、LDAP エントリに対するオブジェクト指向のインターフェースを提供します。

<wiki:comment>
  The target audience is system administrators and LDAP users everywhere
  that need quick, clean access to LDAP in Ruby. 
</wiki:comment>
対象読者はシステム管理者やLDAPユーザであって、手軽かつきれいなLDAPアクセスの方
法を求めるすべての人です。

<wiki:comment>
  What's LDAP?
</wiki:comment>
== LDAP とは何か ==

<wiki:comment>
    LDAP stands for "Lightweight Directory Access Protocol." Basically this
    means that it is the protocol used for accessing LDAP servers. LDAP
    servers lightweight directories. An LDAP server can contain anything
    from a simple digital phonebook to user accounts for computer systems.
    More and more frequently, it is being used for the latter. My examples
    in this text will assume some familiarity with using LDAP as a
    centralized authentication and authorization server for Unix systems.
    (Unfortunately, I've yet to try this against Microsoft's
    ActiveDirectory, despite what the name implies.) 
</wiki:comment>
LDAPは”軽量ディレクトリアクセスプロトコル”のことです。これは基本的にLDAPサーバ
と対話するためのプロトコルを意味します。LDAPサーバは軽量のディレクトリサーバで
す。LDAPサーバはシンプルな電話帳からコンピュータ上のユーザアカウントのリストま
で、幅広い情報を格納することができますが、大抵の場合後者のために使われます。

このテキストでの各例は、読者が LDAPサーバを Unix 系システムのための中央認証・認
可サーバとして利用することを熟知しているものと仮定して記載しています。（残念なこ
とに、私はまだMicrsoft ActiveDirectoryに対して ActiveLdap を試していません。名
前に "Directory" が含まれていはいるのですが。）

<wiki:comment>
  Further reading:
    * RFC1777 - Lightweight Directory Access Protocol
    * OpenLDAP
</wiki:comment>
より理解するために：
  * RFC1777 - 軽量ディレクトリアクセスプロトコル
  * OpenLDAP

<wiki:comment>
  So why use ActiveLdap?
</wiki:comment>
== では何故 ActiveLdap なのか？ ==

<wiki:comment>
  不要？
  Well if you like to fumble around in the dark, dank innards of LDAP, you can
  quit reading now. However, if you'd like a cleaner way to integrate LDAP in to
  your existing code, hopefully that's why you'll want to use ActiveLdap. 
</wiki:comment>

<wiki:comment>
  Using LDAP directly (even with the excellent Ruby/LDAP), leaves you bound to
  the world of the predefined LDAP API. While this API is important for many
  reasons, having to extract code out of LDAP search blocks and create huge
  arrays of LDAP.mod entries make code harder to read, less intuitive, and just
  less fun to write. Hopefully, ActiveLdap will remedy all of these
  problems! 
</wiki:comment>
LDAPを直接扱うさいには（たとえ素晴らしい Ruby/LDAP ライブラリを用いても）、既存
の LDAP API に拘束されることになります。このAPIは巨大な配列を生成し、コードを読
みづらく、また楽しくないものにしてしまいます。もしあなたがあなたのコードにLDAPを
統合するためのきれいな方法を欲するなら、ActiveLdap を使う理由になるでしょう。

<wiki:comment>
  Getting Started
</wiki:comment>
= 利用準備 =

<wiki:comment>
  ActiveLdap does have some overhead when you get started. You must not only
  install the package and all of it's requirements, but you must also make
  customizations that will let it work in your environment. 

  ※自明すぎるので削除
  ActiveLdap を利用する前に動作条件を満たす必要があります。

  ※たぶん configuration.rb を編集してた頃とかの名残なので無かったことに
  また環境に応じて使いやすいようにカスタマイズすることも可能です。
</wiki:comment>
<wiki:comment>
  Requirements
      * A Ruby implementation: Ruby 1.8.x, 1.9.1 or JRuby 1.1
      * A LDAP library: Ruby/LDAP (for Ruby), Net::LDAP (for Ruby or JRuby) or JNDI (for JRuby)
      * A LDAP server: OpenLDAP, etc
            o Your LDAP server must allow root_dse queries to allow for schema queries
</wiki:comment>
== 動作条件 ==
 * Ruby実装: Ruby 1.8.x または 1.9.1 または JRuby 1.1
 * LDAPライブラリ: Ruby/LDAP (Ruby の場合) または Net::LDAP (Ruby か JRuby の場合) または JNDI (JRuby の場合)
 * LDAP サーバ: OpenLDAP など
  * 利用する LDAP サーバはスキーマクエリのために root_dse クエリを許可していなければなりません

<wiki:comment>
  Installation
</wiki:comment>
== インストール ==

<wiki:comment>
  Assuming all the requirements are installed, you can install by grabbing the
  latest tgz file from the download site.

  The following steps will get the ActiveLdap installed in no time!

    $ tar -xzvf ruby-activeldap-current.tgz
    $ cd ruby-activeldap-VERSION

  Edit lib/active_ldap/configuration.rb replacing values to match what will work
  with your LDAP servers. Please note that those variables are required, but can
  be overridden in any program as detailed later in this document. Also make
  sure that "ROOT" stays all upcase.

  Now run:

    $ (as root) rake install

  Now as a quick test, you can run:

    $ irb
    irb> require 'active_ldap'
    => true
    irb> exit

  If the require returns false or an exception is raised, there has been a
  problem with the installation. You may need to customize what setup.rb does on
  install. 
</wiki:comment>

インストールは gem で行えます。
{{{
  gem install activeldap
}}}

インストールされたか確認するには、irb を利用できます。以下のように require して、
true が返ってくればインストール成功です。
{{{
$ irb -rubygems
irb(main):001:0> require 'active_ldap'
=> true
irb(main):002:0>
}}}

もし require が false を返したり例外を発生させたら、インストールに失敗していま
す。動作条件を満たしているかなどを確認してみてください。

<wiki:comment>
※obsolete っぽいのでいったんコメントアウト
  Customizations
== カスタマイズ ==

  Now that ActiveLdap is installed and working, we still have a few more steps
  to make it useful for programming. 

ActiveLdap はインストールされ動作可能です。もう少し便利にプログラミングするため
のカスタマイズが可能です。

  Let's say that you are writing a Ruby program for managing user and group
  accounts in LDAP. I will use this as the running example throughout the
  document.

あなたのLDAP上のユーザ/グループアカウントを管理するために Ruby プログラミングを
するとしましょう。このドキュメントのコード例はそれを想定して記載していきます。

  You will want to make a directory called 'ldapadmin’ wherever is convenient.
  Under this directory, you'll want to make sure you have a 'lib’ directory. 

  $ cd ~
  $ mkdir ldapadmin
  $ cd ldapadmin
  $ mkdir lib
  $ cd lib

利便性のために、`ldapadmin'　ディレクトリを作成することをお勧めします。この下に
は lib ディレクトリを作成する必要があります。

{{{
  $ cd ~
  $ mkdir -p ldapadmin/lib
  $ cd ldapadmin/lib
}}}

  The lib directory is where we'll be making customizations. You can, of course,
  make this changes somewhere in Ruby's default search path to make this
  accessible to every Ruby scripts. Enough of my babbling, I'm sure you'd like
  to know what we're going to put in lib/. 

lib ディレクトリは私たちがカスタマイズを行う場所です。もちろん、この場所はすべて
の Ruby スクリプトがアクセスできるように Ruby のデフォルトサーチパスに変更するこ
ともできます。私のおしゃべりはもういいでしょう。あなたが lib/ ディレクトリに何を
置くのか知りたがっているのもわかっています。

  We're going to put extension classes in there. What are extension classes you
  say . . . 

わたしたちはここに拡張クラスを配置します。拡張クラスが何かというと…
</wiki:comment>

<wiki:comment>
  Usage
</wiki:comment>
= 利用方法 =

<wiki:comment>
  This section covers using ActiveLdap from writing extension classes to
  writing applications that use them. 
</wiki:comment>
この章では ActiveLdap 拡張クラスをコーディングし、アプリケーションを記述し、それ
らを利用するまでを記載します。

<wiki:comment>
  Just to give a taste of what's to come, here is a quick example using irb: 
  irb> require 'active_ldap'
</wiki:comment>
何を得られるかざっくりつかむために、irb を利用して簡単な例を紹介しましょう。まず
ActiveLdap を require します。

{{{
  irb> require 'active_ldap'
}}}

LDAPサーバとの接続を確立します。ここでは最も基本的なメソッドである
setup_connection を利用します。サンプルとして、接続先は localhost、base を
"dc=dataspill,dc=org" とします。

{{{
  ActiveLdap::Base.setup_connection :host => 'localhost', :base => 'dc=dataspill,dc=org'
}}}

<wiki:comment>
  Here's an extension class that maps to the LDAP Group objects:
</wiki:comment>
次に、ActiveLdap::Base のサブクラスを作成します。これを拡張クラスと呼びます。こ
の拡張クラスを、 base 以下に存在する LDAP の Group オブジェクト群とマッピングし
てみましょう。

{{{
  irb> class Group < ActiveLdap::Base
  irb*   ldap_mapping
  irb* end
}}}

<wiki:comment>
  Here is the Group class in use:
</wiki:comment>

<wiki:comment>日本語版追記</wiki:comment>
簡単に説明しましょう。上記のコードでは Group クラスが setup_connection でした:
base 以下の ou=Groups 以下のオブジェクト群全体を取り扱うようになります。Groupク
ラスのインスタンスは、ou=Groups 以下にある個々の LDAP オブジェクトを表現します。

これで、グループクラスは以下のように利用できます
{{{
  # 全てのグループ名を取得
  irb> all_groups = Group.find(:all).collect {|group| group.cn}
  => ["root", "daemon", "bin", "sys", "adm", "tty", ..., "develop"]

  # develop グループの LDAP オブジェクトを取得
  irb> group = Group.find("develop")
  => #<Group objectClass:<...> ...>

  # develop グループの cn を取得
  irb> group.cn
  => "develop"

  # develop グループの gid_number を取得
  irb> group.gid_number
  => 1003
}}}

<wiki:comment>
That's it! No let's get back in to it. 
</wiki:comment>
ほら！ もう元には戻れないでしょう？

<wiki:comment>
  Extension Classes
</wiki:comment>
== ActiveLdap 拡張クラス ==
<wiki:comment>
  Extension classes are classes that are subclassed from ActiveLdap::Base. They
  are used to represent objects in your LDAP server abstractly.

  Why do I need them?

  Extension classes are what make ActiveLdap "active"! They do all the
  background work to make easy-to-use objects by mapping the LDAP object's
  attributes on to a Ruby class.  
</wiki:comment>
ActiveLdap 拡張クラスは ActiveLdap::Base のサブクラスです。これらは LDAP サーバ
内のオブジェクトを抽象的に表現するために使われます。

拡張クラスは LDAP オブジェクト群の属性情報を Ruby クラスに自動的にマッピングする
ことで、オブジェクトの取り扱いを容易かつ便利にします。

<wiki:comment>
  Special Methods
</wiki:comment>
== 拡張クラス定義用メソッド ==

<wiki:comment>
  I will briefly talk about each of the methods you can use when defining an
  extension class. In the above example, I only made one special method call
  inside the Group class. More than likely, you will want to more than that.
</wiki:comment>
LDAP オブジェクトが正しく Ruby オブジェクトにマッピングされるために、ActiveLdap
のクラスメソッドを利用してマッピングのための情報を定義します。上記の例ではそれら
のうち、Group クラスを定義する中で ldap_mapping だけを利用していました。必要に応
じて更に多くのメソッドを利用することができます。

<wiki:comment>
  ldap_mapping
</wiki:comment>
=== ldap_mapping ===

<wiki:comment>
  ldap_mapping is the only required method to setup an extension class for use
  with ActiveLdap. It must be called inside of a subclass as shown above.
</wiki:comment>

ldap_mapping は ActiveLdap とともに拡張クラスを利用するにあたって必須とされる唯
一のメソッドです。

<wiki:comment>
  Below is a much more realistic Group class:
</wiki:comment>
以下は ldap_mapping を更に詳細に記述した Group クラスです

{{{
  class Group < ActiveLdap::Base
    ldap_mapping :dn_attribute => 'cn',
                 :prefix => 'ou=Groups',
                 :classes => ['top', 'posixGroup']
                 :scope => :one
  end
}}}

<wiki:comment>
  As you can see, this method is used for defining how this class maps in to
  LDAP. Let's say that my LDAP tree looks something like this:
</wiki:comment>
Group クラスをどのようにして LDAP とマッピングとするかを定義するために、
ldap_mapping メソッドが使われていることが見てとれるでしょう。

私たちが扱う LDAP ツリーが以下のようなものであるとします。

{{{
  * dc=dataspill,dc=org
  |- ou=People,dc=dataspill,dc=org
  |+ ou=Groups,dc=dataspill,dc=org
     |- cn=develop,ou=Groups,dc=dataspill,dc=org
     |- cn=root,ou=Groups,dc=dataspill,dc=org
     |- ...
}}}

<wiki:comment>
  Under ou=People I store user objects, and under ou=Groups, I store group
  objects. What |ldap_mapping| has done is mapped the class in to the LDAP tree
  abstractly. With the given :dn_attributes and :prefix, it will only work for
  entries under ou=Groups,dc=dataspill,dc=org using the primary attribute 'cn’
  as the beginning of the distinguished name.
</wiki:comment>
ou=People 以下にはユーザオブジェクトを格納し、ou=Groups 以下にはグループオブジェ
クトを格納するものとします。

ldap_mapping は LDAP ツリーを抽象化して拡張クラスにマッピングします。以下では、
先の Group クラスの例をとって説明します。

:prefix によって、このクラスはou=Groups,dc=dataspill,dc=org 以下のみを扱うように
なっています。

:dn_attributeにより 'cn' がこのクラスにとってのプライマリ属性となります。つまり、
Group クラスが取り扱う LDAPオブジェクト(ou=Groups,dc=dataspill,dc=org 以下のLDAP
オブジェクト)について、DN はcn から始まるものとして扱われます。

<wiki:comment>
  Just for clarity, here's how the arguments map out:
</wiki:comment>
より理解をはっきりさせるために、図にしてみましょう。各引数は図のようにマッピングされます。

{{{
  cn=develop,ou=Groups,dc=dataspill,dc=org
  ^^         ^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^
 :dn_attribute |         |
             :prefix     |
                       :base from configuration(setup_connection,
                                                 define_configuration etc)
}}}

<wiki:comment>
  :scope tells ActiveLdap to only search under ou=Groups, and not to look deeper
  for dn_attribute matches. (e.g.
  cn=develop,ou=DevGroups,ou=Groups,dc=dataspill,dc=org)
</wiki:comment>
他にも :scope, :classes, :dn_attribute といったオプションの引数があります。

:scope は ou=Groups 以下の検索について、より深い階層までを検索するかどうかを指示
します（cn=develop,ou=DevGroups,ou=Groups,dc=dataspill,dc=org のような LDAP オブ
ジェクトのこと）。<wiki:comment>日本語版追記</wiki:comment> ここには、:base,
:one, :sub といった引数を指定できます。

<wiki:comment>
  Something's missing: :classes. :classes is used to tell ActiveLdap what
  the minimum requirement is when creating a new object. LDAP uses objectClasses
  to define what attributes a LDAP object may have. ActiveLdap needs to
  know what classes are required when creating a new object. Of course, you can
  leave that field out to default to ['top’] only. Then you can let each
  application choose what objectClasses their objects should have by calling the
  method e.g. Group#add_class(*values).
</wiki:comment>
:classes は ActiveLdap に対して、新しいオブジェクトを生成するのに必要な最低
条件を指定します。LDAP はオブジェクトクラスを利用して、LDAPオブジェクトがどのよ
うな属性を持ち得るかを定義します。ActiveLdap はこれを :classes 引数によって
知ることになります。デフォルトは 'top' のみです。このままにすることもできます
し、add_class メソッドなどによって追加することも可能です。

<wiki:comment>
  Note that is can be very important to define the default :classes value. Due
  to implementation choices with most LDAP servers, once an object is created,
  its structural objectclasses may not be removed (or replaced). Setting a sane
  default may help avoid programmer error later.
</wiki:comment>
デフォルトの :classes の値はとても重要です。ほとんどの LDAP サーバは一度オブジ
ェクトが造られると structual な objectClass は削除（または変更）されることはない
でしょう。健全なデフォルトを設定しておくことは、後々バグを作り込むことを回避する
助けになるかもしれません。

<wiki:comment>
  :classes isn't the only optional argument. If :dn_attribute is left off, it
  defaults to super class's value or 'cn’. If :prefix is left off, it will
  default to 'ou=PLURALIZED_CLASSNAME’. In this case, it would be 'ou=Groups’.
</wiki:comment>

:classes だけがオプションの引数ではありません。:dn_attribute が無い場合、このデ
フォルトはスーパークラスと同じ値か、cn に設定されます。

:prefixが無い場合、このデフォルトは'ou=クラス名の複数形’に設定されます。この場
合は'ou=Groups'になります。

<wiki:comment>
  :classes should be an Array. :dn_attribute should be a String and so should
  :prefix.
</wiki:comment>
:classes は配列でなくてはなりません。:dn_attribute と :prefix は文字列である必要
があります。

=== belongs_to ===

<wiki:comment>
  This method allows an extension class to make use of other extension classes
  tying objects together across the LDAP tree. Often, user objects will be
  members of, or belong_to, Group objects.
</wiki:comment>
このメソッドはLDAPツリーを横断して他の拡張クラスとの関連付けを行い、所属の表現を
行います。しばしば User オブジェクトは Group オブジェクトのメンバになったり、所
属したりします。

{{{
  * dc=dataspill,dc=org
  |+ ou=People,dc=dataspill,dc=org
   \
   |- uid=drewry,ou=People,dc=dataspill,dc=org
  |- ou=Groups,dc=dataspill,dc=org
}}}

<wiki:comment>
  In the above tree, one such example would be user 'drewry’ who is a part of
  the group 'develop’. You can see this by looking at the 'memberUid’ field of
  'develop’.
</wiki:comment>
上記のようなLDAPツリーでは、'drewry'ユーザは　'develop' グループの一員であるとし
ます。この場合、'develop' グループの 'memberUid' フィールドを見ることで、それを
確認できます。

{{{
  irb> develop = Group.find('develop')
  => ...
  irb> develop.memberUid
  => ['drewry', 'builder']
}}}

<wiki:comment>
  If we look at the LDAP entry for 'drewry’, we do not see any references to
  group 'develop’. In order to remedy that, we can use belongs_to
</wiki:comment>
しかし、'drewry' のエントリを見た時に 'develop' グループと関連している事は判らな
いでしょう。これを解決するために belongs_to を利用します。

<wiki:comment>日本語版で整理</wiki:comment>
{{{
  irb> class User < ActiveLdap::Base
  irb*   ldap_mapping :dn_attribute => 'uid', :prefix => 'People', :classes => ['top','account']
  irb*   belongs_to :groups,  :foreign_key => 'uid', 
  irb*                :class_name => 'Group', :many => 'memberUid'
  irb* end
}}}

<wiki:comment>
  Now, class User will have a method called 'groups’ which will retrieve all
  Group objects that a user is in.
</wiki:comment>
これで User クラスは 'groups' メソッドを利用できるようになります。このメソッドは
ユーザが所属するすべての Group オブジェクトを取得することができます。

{{{
  irb> me = User.find('drewry')
  irb> me.groups
  => [#<Group ...>, #<Group ...>, ...]
  irb> me.groups.each { |group| p group.cn };nil
  "cdrom"
  "audio"
  "develop"
  => nil
  (注:irb 上の見やすさのために nil を返すようにしています)
}}}

<wiki:comment>
  TIP: If you weren't sure what the distinguished name attribute was for Group,
  you could also do the following:
</wiki:comment>
TIP: 上記では Group の Distinguished name が cn であると仮定しています。もし
Group の Distinguished name の属性名を知らなければ、以下のようにすれば
（Distinguished name がなんであれ）Distinguished name の属性を取得できます。

{{{
  irb> me.groups.each { |group| p group.id };nil
  "cdrom"
  "audio"
  "develop"
  => nil
}}}

<wiki:comment>
  Now let's talk about the arguments. The first argument is the name of the
  method you wish to create. In this case, we created a method called groups
  using the symbol :groups. The next collection of arguments are actually a Hash
  (as with ldap_mapping). :class_name should be a string that has the name of a class
  you've already included. If you class is inside of a module, be sure to put
  the whole name, e.g. :class_name => "MyLdapModule::Group". :foreign_key tells
  belongs_to what attribute Group objects have that match the :many. :many is
  the name of the local attribute whose value should be looked up in Group under
  the foreign key. If :foreign_key is left off of the argument list, it is
  assumed to be the dn_attribute. With this in mind, the above definition could
  become:
</wiki:comment>
belongs_to の引数について説明します。<wiki:comment>日本語版追記</wiki:comment>理
解の助けのため、先ほどの Group クラスを少し拡張した以下のコードを例にとって説明
します。

<wiki:comment>日本語版で追加</wiki:comment>
{{{
class User < ActiveLdap::Base
  ldap_mapping :dn_attribute => 'uid', :prefix => 'People', :classes => ['top','account']

  # プライマリで所属しているグループと関連付け
  belongs_to :primary_group, :foreign_key => 'gidNumber',
               :class_name => 'Group', :primary_key => 'gidNumber'

  # 所属しているグループ全てと関連付け
  belongs_to :groups,  :foreign_key => 'uid',
               :class_name => 'Group', :many => 'memberUid',
end
}}}

belongs_to の最初の引数は造りたいメソッドの名前を Symbol で指定します。ここでは、
primary_group メソッドと groups メソッドを作成しています。次以降の引数は実際には
Hashです（ldap_mapping のように）。

:foreign_key には、関連のキー値を持つ、自身の属性名を指定します。:foreign_keyに
何も設定しないと、自動的に ldap_mapping で指定した :dn_attribute の属性名が利用
されます。

  例では :foreign_key に uid を指定していますが、これに違和感を覚えたかもしれま
  せん。

  ActiveLdapでの :foreign_key には "自身の属性名を指定する”という規約がありま
  す。このため、必ずしも名前通りの”外部キー”とはならない場合があります。
  belongs_toにおける :foreign_key は、単に所属の関連性を示すためのキーにすぎない
  と考えた方が良いかも知れません。

  後述する :primary_key も同様に”相手先の属性名を指定する”という規約が適用され
  ています。

:class_name キーには、所属先となるオブジェクトの拡張クラス名を、 String で指定し
ます。もし拡張クラスがモジュールやクラスの中に定義されている場合、:class_name =>
"MyLdapModule::Group" のようにトップレベルから全ての名前を記載してください。この
例では "Group" クラスを指定しています。

:many と :primary_key は両方とも似た意味を持ちます。どちらも、:foreign_key の参
照先属性名を指定します。指定する属性名は :class_name で指定した拡張クラスのイン
スタンスで利用できる属性名です。

所属の関連付けは、:foreign_key に指定した属性の値を用い、 :class_name に指定の拡
張クラス配下のオブジェクト群を検索することによって行われます。この際の検索対象属
性が :primary_key または :many に指定の属性です。例で定義した parimary_group メ
ソッドで言えば、User オブジェクトの gidNumber の値で、 Groupオブジェクト群の属性
gidNumber を検索します。マッチした Group オブジェクトが所属先となります。

:parimary_key は所属先がただ一つの場合に利用します。検索の結果、最初にマッチした
もののみが所属先として扱われます。

:many は所属先が複数の場合に利用します。検索の結果マッチしたすべてのオブジェクト
が所属先として扱われます。

<wiki:comment>
  In addition, you can do simple membership tests by doing the following:
</wiki:comment>
尚、:many を利用していると、メンバーシップテストも下記のように行えます。

{{{
  irb> me.groups.member? 'root'
  => false
  irb> me.groups.member? 'develop'
  => true
}}}

=== has_many ===

<wiki:comment>
  This method is the opposite of belongs_to. Instead of checking other objects
  in other parts of the LDAP tree to see if you belong to them, you have
  multiple objects from other trees listed in your object. To show this, we can
  just invert the example from above:
</wiki:comment>
このメソッドは belongs_to と対のものです。特定のオブジェクトに所属しているエント
リを、所属されているオブジェクトからリスト可能にします。これを行うにはbelongs_to
とは逆のことをします。

{{{
class Group < ActiveLdap::Base
  ldap_mapping :dn_attribute => 'cn', :prefix => 'ou=Groups', :classes => ['top', 'posixGroup']

  # プライマリで所属しているユーザ群と関連付け
  has_many :primary_members, :foreign_key => 'gidNumber',
            :class_name => "User", :primary_key => 'gidNumber'

  # 所属しているユーザ全てと関連付け
  has_many :members,  :wrap => "memberUid",
            :class_name => "User",  :primary_key => 'uid'
end
}}}

<wiki:comment>
  Now we can see that group develop has user 'drewry’ as a member, and it can
  even return all responses in object form just like belongs_to methods.
</wiki:comment>
これで develop グループが 'drewry' ユーザをメンバーとして見ることができます。
belongs_to のように、メンバーのリストを members メソッドによって取得することがで
きます。

{{{
  irb> develop = Group.find('develop')
  => ...
  irb> develop.members
  => [#<User ...>, #<User ...>]
}}}

<wiki:comment>
  The arguments for has_many follow the exact same idea that belongs_to's
  arguments followed. :wrap's contents are used to search for matching
  :primary_key content. If :primary_key is not specified, it defaults to the
  dn_attribute of the specified :class_name.  
</wiki:comment>
has_many の引数は belongs_to とまったく同じ形式をとります。つまり第一引数に実装
するメソッド名を Symbol で渡し、続く引数は Hash です。

:class_name、:parimary_key の意味合いも belongs_to と同様で、相手先の拡張クラス
名と参照先の属性名を指定します。相手先が所有先になるだけです。尚、 has_many に
:many キーはありません。

belonsg_to と違う点は、自身の関連性のキー属性を指定するオプションが二つあること
です。:foreign_key か :wrap のいずれかで指定します。

:foreign_key で属性名を指定した場合、has_many は単純に :class_name のクラスに対
して検索を行い、マッチしたオブジェクト群を所有オブジェクト群として扱います。

:wrap で指定した場合は挙動が変わります。:wrap の概念は”:wrap に指定した属性に保
持する値をオブジェクト化する”ことです。

:wrap に指定する属性は、memberUid のように一つ以上の値を持つことを想定しています。
この属性に保持する全ての値で検索し、マッチする全てのオブジェクトを返します。マッ
チしない値がある場合、:class_name に指定の拡張クラスで new され、所有対象のリス
トに含まれます。

<wiki:comment>
  Using these new classes
</wiki:comment>
== 拡張クラスの利用法 ==

<wiki:comment>
  These new classes have many method calls. Many of them are automatically
  generated to provide access to the LDAP object's attributes. Other were
  defined during class creation by special methods like belongs_to. There are a
  few other methods that do not fall in to these categories.
</wiki:comment>
作成した拡張クラスは多くのメソッドコールを持ちます。それらのうちの多数は LDAP
オブジェクトに対するアクセスを提供するために自動的に作成されています。他のメソッ
ドはクラス定義時、belongs_to のような特別なメソッドによって作成されます。以下で
はそれら以外のメソッドについて記載します。

=== .find ===

<wiki:comment>
  .find is a class method that is accessible from any subclass of Base that has
  'ldap_mapping’ called. When called .find(:first) returns the first match of the given
  class.

  irb> Group.find(:first, 'deve*').cn
  => "develop"

  In this simple example, Group.find(:first) took the search string of 'deve*’ and
  searched for the first match in Group where the dn_attribute matched the
  query. This is the simplest example of .find.
</wiki:comment>
.find は ldap_mapping をコール済みの拡張クラスのクラスメソッドです。ActiveRecord
のようにLDAPオブジェクトを検索可能です。

文字列を与えると、dn_attribute をキーにして最初にマッチするオブジェクトを返しま
す。
{{{
  irb> Group.find(:first, 'develop')
  => #<Group ...>
  irb> Group.find(:first, 'develop').cn
  => "develop"
  irb> Group.find(:first, 'develop').members
  => ['drewry']
}}}

<wiki:comment>
  * obsolete *
    irb> Group.find(:all).collect {|group| group.cn} => ["root", "daemon",
    "bin", "sys", "adm", "tty", ..., "develop"]

  Here .find(:all) returns all matches to the same query. Both .find and
  .find(:all) also can take more expressive arguments:

  irb> Group.find(:all, :attribute => 'gidNumber', :value => '1003').collect {|group| group.cn}
  => ["develop"]
</wiki:comment>

最初のキーに :all を与えると全てのオブジェクトを返します。
{{{
  irb> Group.find :all
  => [#<Group ...>, #<Group ...>, #<Group ...>]
  irb> Group.find :all, :filter => '(gidNumber=2*)'
  => [#<Group ...>, #<Group ...>]
}}}

<wiki:comment>
  So it is pretty clear what :attribute and :value do - they are used to query
  as :attribute=:value.

  If :attribute is unspecified, it defaults to the dn_attribute.
</wiki:comment>
:attribute と :value によって特定のキーについて検索することも可能です。
:attribute が指定されない場合、:dn_attribute が利用されます。
{{{
  irb> Group.find(:all, :attribute => 'gidNumber', :value => '1003').collect{|g| g.cn}
  => ["develop"]
}}}

<wiki:comment>
  It is also possible to override :attribute and :value by specifying :filter.
  This argument allows the direct specification of a LDAP filter to retrieve
  objects by.
</wiki:comment>
:filter によってLDAPフィルタを直接指定することも可能です。
{{{
  irb> Group.find(:all, :filter => '(gidNumber=1003)').collect{|g| g.cn}
  => ["develop"]
}}}

=== .search ===

<wiki:comment>
  .search is a class method that is accessible from any subclass of Base, and
  Base. It lets the user perform an arbitrary search against the current LDAP
  connection irrespetive of LDAP mapping data. This is meant to be useful as a
  utility method to cover 80% of the cases where a user would want to use
  Base.connection directly.
</wiki:comment>
.search は ActiveLdap::Base か、そのサブクラスから呼び出し可能なクラスメソッドで
す。拡張クラスと LDAPツリーとのマッピングを無視して検索することができます。直接
Base.connection を利用してもよいですが、このメソッドを利用すれば8割の目的は達成
できるでしょう。

{{{
  irb> Base.search(:base => 'dc=example,dc=com', :filter => '(uid=roo*)',
                   :scope => :sub, :attributes => ['uid', 'cn'])
  =>  [["uid=root,ou=People,dc=dataspill,dc=org",{"cn"=>["root"], "uidNumber"=>["0"]}]
}}}

<wiki:comment>
  You can specify the :filter, :base, :scope, and :attributes, but they all have
  defaults ?
</wiki:comment>
:filter, :base, :scope, :attributes の各キーを指定できます。それぞれにデフォルト
の値を持っています。

<wiki:comment>
   * :filter defaults to objectClass=* - usually this isn't what you want
   * :base defaults to the base of the class this is executed from (as set in
     ldap_mapping)
   * :scope defaults to :sub. Usually you won't need to change it
   * :attributes defaults to [] and is the list of attributes you want back.
     Empty means all of them.
</wiki:comment>
  * :filter のデフォルトは "objectClass=*" です。たいていの場合、変更する必要があるでしょう
  * :base のデフォルトはこのメソッドを実行したクラスの :base です。これは ldap_mapping によって設定されているものです
  * :scope は :sub に設定されています。
  * :attributes のデフォルトは [] です。これはあなたが欲しい属性名のリストを指定してください。空の場合はすべての属性を取得します

=== valid? ===

<wiki:comment>
  valid? is a method that verifies that all attributes that are required by the
  objects current objectClasses are populated.
</wiki:comment>
valid? はインスタンスメソッドです。オブジェクトクラスで必要とされる属性が備わっ
ているか検査します。真偽値を返します。

=== save ===

<wiki:comment>
  save is a method that writes any changes to an object back to the LDAP server.
  It automatically handles the addition of new objects, and the modification of
  existing ones.
</wiki:comment>
save は LDAP オブジェクトの変更を保存するためのインスタンスメソッドです。実行す
ると、レシーバのオブジェクトに加えられていた変更が LDAP サーバに反映されます。新
しいオブジェクトか、既存のオブジェクトかを自動判別し、新規オブジェクトならLDAPサ
ーバに追加します。既存のものならば更新します。

=== .exists? ===

<wiki:comment>
  exists? is a simple method which returns true is the current object exists in
  LDAP, or false if it does not.
</wiki:comment>
exists? はシンプルなクラスメソッドです。ある :dn_attribute を持つオブジェクトが
存在するか検査したい時に利用します。

{{{
 irb> User.exists?("dshadsadsa")
 => false
}}}

== ActiveLdap::Base ==

<wiki:comment>
  ActiveLdap::Base has come up a number of times in the examples above. Every
  time, it was being used as the super class for the wrapper objects. While this
  is it's main purpose, it also handles quite a bit more in the background.
</wiki:comment>
ActiveLdap::Base はこれまでの例の中で何回か登場してきました。主な目的としてLDAP
オブジェクトをラップするために拡張クラスのスーパークラスとして活用しましたが、も
う少しその背景を記載します。

<wiki:comment>
  What is it?
</wiki:comment>
=== これは何か ====

<wiki:comment>
  ActiveLdap::Base is the heart of ActiveLdap. It does all the schema parsing
  for validation and attribute-to-method mangling as well as manage the
  connection to LDAP.
</wiki:comment>
ActiveLdap::Base は ActiveLdap の心臓部です。属性を setter/getter にマッピングし
たり、バリデーションを行うためのスキーマ解析を行います。同時に、LDAPサーバとの接
続の管理も行います。

=== setup_connection ===

<wiki:comment>
  Base.setup_connection takes many (optional) arguments and is used to connect
  to the LDAP server. Sometimes you will want to connect anonymously and other
  times over TLS with user credentials. Base.setup_connection is here to do all
  of that for you.
</wiki:comment>
Base.setup_connection は LDAP サーバとの接続のために多くの引数をとります。多くは
オプションの引数です。時に匿名接続を行いたいでしょうし、時にはユーザ証明とともに
TLSを利用した接続をしたいでしょう。Base.setup_connection はそれらを実現します。

<wiki:comment>
  By default, if you call any subclass of Base, such as Group, it will call
  Base.setup_connection() if these is no active LDAP connection. If your server
  allows anonymous binding, and you only want to access data in a read-only
  fashion, you won't need to call Base.setup_connection. Here is a fully
  parameterized call:
</wiki:comment>
Group のような、Base を親に持つサブクラスをコールした際、まだ接続が確立していなけ
れば、Base.setup_connection で設定した情報をもとに接続しようと試みます。あなたの
サーバが匿名バインドを許していて、かつ読み取り専用でのアクセスを行いたいのな
ら、多くを設定する必要はないでしょう。以下にパラメータつきの setup_connection の
例を示します。

{{{
  Base.setup_connection(
    :host => 'ldap.dataspill.org',
    :port => 389,
    :base => 'dc=dataspill,dc=org',
    :logger => logger_object,
    :bind_dn => "uid=drewry,ou=People,dc=dataspill,dc=org",
    :password_block => Proc.new { 'password12345' },
    :allow_anonymous => false,
    :try_sasl => false
  )
}}}

<wiki:comment>
  There are quite a few arguments, but luckily many of them have safe defaults:
</wiki:comment>
多くの引数がありますが、そのうちの多くには安全なデフォルト値が設定設定されていま
す。

<wiki:comment>
    * :host defaults to @@host from configuration.rb waaay back at the setup.rb stage.
    * :port defaults to @@port from configuration.rb as well
    * :base defaults to Base.base() from configuration.rb
    * :bind_dn defaults @@bind_format from configuration.rb
    * :logger defaults to a Logger object that prints fatal messages to stderr
    * :password_block defaults to nil
    * :allow_anonymous defaults to true
    * :try_sasl defaults to false - see Advanced Topics for more on this one.
</wiki:comment>

 * :host のデフォルト値は '127.0.0.1' です
 * :port は nil です。何も設定しない場合は 389 が利用されます
 * :bind_dn は nil です。何も設定しない場合、匿名アクセスとなります。
 * :logger はロガーオブジェクトを設定します。デフォルトでは Logger オブジェクトです。
 * :password_block のデフォルトは nil です。
 * :allow_anonymous のデフォルトは true です
 * :try_sasl のデフォルトは false になっています。このオプションについては後述の "高度な話題" をご覧ください

<wiki:comment>
  Most of these are obvious, but I'll step through them for completeness:
</wiki:comment>
実際に利用可能な引数のリストを示します。

<wiki:comment>
    * :host defines the LDAP server hostname to connect to.
    * :port defines the LDAP server port to connect to.
    * :method defines the type of connection - :tls, :ssl, :plain
    * :base specifies the LDAP search base to use with the prefixes defined in all subclasses.
    * :bind_dn specifies what your server expects when attempting to bind with credentials.
    * :logger accepts a custom logger object to integrate with any other logging your application uses.
    * :password_block, if defined, give the Proc block for acquiring the password
    * :password, if defined, give the user's password as a String
    * :store_password indicates whether the password should be stored, or if used whether the :password_block should be called on each reconnect.
    * :allow_anonymous determines whether anonymous binding is allowed if other bind methods fail
    * :try_sasl, when true, tells ActiveLdap to attempt a SASL-GSSAPI bind
    * :sasl_quiet, when true, tells the SASL libraries to not spew messages to STDOUT
    * :method indicates whether to use :ssl, :tls, or :plain
    * :retries - indicates the number of attempts to reconnect that will be undertaken when a stale connection occurs. -1 means infinite.
    * :retry_wait - seconds to wait before retrying a connection
    * :scope - dictates how to find objects. (Default: :one)
    * :timeout - time in seconds - defaults to disabled. This CAN interrupt search() requests. Be warned.
    * :retry_on_timeout - whether to reconnect when timeouts occur. Defaults to true
</wiki:comment>

 * :host は接続先LDAPサーバのホスト名を指定します
 * :port は接続先LDAPサーバのポートを指定します
 * :method は接続方法を指定します。 :tls, :ssl, :plain が指定可能です
 * :base は LDAPの検索開始位置を指定します。これは Base のサブクラスで :prefix とともに利用されます
 * :bind_dn はユーザ認証を伴った接続をする際に指定します。バインドする dn を指定します。
 * :logger はカスタマイズしたロガーオブジェクトを指定します。あなたが利用したいロガーを渡すことができます。
 * :password_block には Proc オブジェクトを渡します。このブロックを実行した結果の戻り値がパスワードとして利用されます
 * :password にはパスワードの文字列を指定します
 * :store_password には真偽値を設定します。再接続の際に :password_block で指定したブロックを再実行するかどうかが決定されます。このキーが存在する場合、password_block の実行結果は保存され、ブロックが再実行されることはありません
 * :allow_anonymous は接続の際、バインドに失敗した場合、匿名で接続することを許可します
 * :try_ssl が true の場合、SASL-GSSAPI バインドを試みます
 * :sasl_quiet が true の場合、SASL ライブラリが STDOUT にメッセージを吐かないよう指示します
 * :method は接続方式の指定です。:ssl, :tls または :plain を指定します
 * :retry_limit は接続失敗時に、何回再接続を試みるかを数値で指定します。-1 を指定すると無限に再接続を試みます
 * :retry_on_timeout タイムアウトが発生した場合に再接続を行うかどうかを指定します。デフォルトは true です
 * :retry_wait は再接続するまえに何秒待つかを指定します
 * :scope はLDAPオブジェクトの検索方式を指定します。デフォルトは :one です
 * :timeout は検索のタイムアウト秒数を指定します。デフォルトでは無効になっています。search() リクエストもインターラプトされるため、注意してください

<wiki:comment>
  See lib/configuration.rb for defaults for each option
</wiki:comment>
各オプションのデフォルト値は ActiveLdap::Configuration::DEFAULT_CONFIG に設定されています。

<wiki:comment>
  Base.setup_connection just setups connection
  configuration. A connection is connected and bound when it
  is needed. It follows roughly the following approach:
</wiki:comment>
Base.setup_connection は接続の設定のみを行います。実際にLDAPサーバに接続しバインドするプロセスは必要になったときに一度に実施されます。だいたい、以下のような
アプローチを取ります

<wiki:comment>
      * Connect to host:port using :method
      * If bind_dn and password_block/password, attempt to bind with credentials.
      * If that fails or no password_block and anonymous allowed, attempt to bind anonymously.
      * If that fails, error out.
</wiki:comment>
 * host:port にたいして、:method での接続を行います
 * もし bind_dn と password_block か password が与えられていれば、ユーザ認証を行いバインドしようとします
 * もし認証が失敗するか、パスワードが与えられていない場合、匿名アクセスが許可されていれば、匿名バインドを行います
 * 匿名バインドも失敗すれば、エラー終了します

<wiki:comment>
  On connect, the configuration options passed in are stored in an internal
  class variable which is used to cache the information without
  ditching the defaults passed in from configuration.rb
</wiki:comment>
接続の際、渡された設定オプションはクラス変数の中に格納
されます。このさい、指定されていないオプションはデフォルト値が適用されます。

=== connection ===

<wiki:comment>
  Base.connection returns the ActiveLdap::Connection object.
</wiki:comment>
Base.connection は ActiveLdasp::Connection オブジェクトを返します

<wiki:comment>
  Exceptions
</wiki:comment>
== 例外クラス ==

<wiki:comment>
  There are a few custom exceptions used in ActiveLdap. They are detailed below.
</wiki:comment>
ActiveLdap は幾つかのカスタマイズした例外クラスを扱います。以下にそれを示します。

=== DeleteError ===

<wiki:comment>
  This exception is raised when delete fails. It will include LDAP error
  information that was passed up during the error.
</wiki:comment>
LDAPオブジェクトの削除に失敗した際、この例外が発生します。エラー発生時の LDAP エ
ラーメッセージが含まれます。

=== SaveError ===

<wiki:comment>
  This exception is raised when there is a problem in save updating or creating
  an LDAP entry. Often the error messages are cryptic. Looking at the server
  logs or doing an Ethereal dump of the connection will often provide better
  insight.
</wiki:comment>
LDAP オブジェクトの追加または更新に問題があった場合に発生する例外です。LDAPサー
バのログや Ethereal などによる通信解析によってより詳しい情報が得られるかもしれま
せん。

=== AuthenticationError ===

<wiki:comment>
  This exception is raised during Base.setup_connection if no valid
  authentication methods succeeded.
</wiki:comment>
この例外は setup_connection で :method による指定された認証が成功しなかった場合に発生します。

=== ConnectionError ===

<wiki:comment>
  This exception is raised during Base.setup_connection if no valid connection
  to the LDAP server could be created. Check you configuration.rb,
  Base.setup_connection arguments, and network connectivity! Also check your
  LDAP server logs to see if it ever saw the request.
</wiki:comment>
この例外は setup_connection で指定された接続が確立できなかった場合に発生します。
setup_connection のパラメータや、ネットワークの導通を確認してみてください。ちゃ
んとリクエストが投げられている場合、LDAPサーバのログも確認してみてください。

=== ObjectClassError ===

<wiki:comment>
  This exception is raised when an object class is used that is not defined in
  the schema.
</wiki:comment>
この例外は、LDAPサーバのスキーマ上で定義されていないオブジェクトクラスを利用した
場合に発生します。

<wiki:comment>
  Others
</wiki:comment>
=== その他の例外 ===

<wiki:comment>
  Other exceptions may be raised by the Ruby/LDAP module, or by other
  subsystems. If you get one of these exceptions and think it should be
  wrapped, write me an email and let me know where it is and what you
  expected. For faster results, email a patch!
</wiki:comment>
その他の例外は Ruby/LDAP モジュールか、さらに別のサブシステムから発生します。も
しあなたがそれらの例外を受け取り、ActiveLdap の例外によりラップされるべきだと考
えたら、あなたが何を期待しているかをメールで教えてください。早く結果を出したい場
合、メールにパッチを添付してください。

<wiki:comment>
  Putting it all together
</wiki:comment>
== 実際に動作するサンプルコード ==

<wiki:comment>
  Now that all of the components of ActiveLdap have been covered, it's time to
  put it all together! The rest of this section will show the steps to setup
  example user and group management scripts for use with the LDAP tree described
  above.
</wiki:comment>
ここまでで ActiveLdap のすべてのコンポーネントについて記述しました。さあ、実際に
動作するコードを配置するときです！ 以降では、いままで例に挙げてきた LDAP ツリー
上の、ユーザとグループを管理するためのスクリプトを順番にセットアップしてきま
す。

<wiki:comment>
  All of the scripts here are in the package's examples/ directory.
</wiki:comment>
以下に示すサンプルコードは、ActiveLdap ライブラリの examples/ ディレクトリにも配
置されています。

<wiki:comment>
  Setting up lib/
</wiki:comment>
=== 準備 ===

<wiki:comment>
  前のほうで ldapadmin ディレクトリの作成を削除しているので追加
</wiki:comment>
まず必要なディレクトリを作成します
{{{
  mkdir -p ldapadmin/objects
}}}

<wiki:comment>
  In ldapadmin/lib/ create the file user.rb:
</wiki:comment>
次に、ldapadin/objects/user.rb を作成します。コードは以下のようにしてください。

{{{
require 'objects/group'

class User < ActiveLdap::Base
  ldap_mapping :dn_attribute => 'uid', :prefix => 'ou=People',
               :classes => ['person', 'posixAccount']
  belongs_to :primary_group, :class_name => "Group",
             :foreign_key => "gidNumber", :primary_key => "gidNumber"
  belongs_to :groups, :many => 'memberUid'

  # An example of using the old "return_objects" API with the
  # new ActiveRecord-style API.
  alias groups_mapping groups
  def groups(return_objects=true)
    return groups_mapping if return_objects
    attr = 'cn'
    Group.search(:attribute => 'memberUid',
                 :value => id,
                 :attributes => [attr]).map {|dn, attrs| attrs[attr]}.flatten
  end
end
}}}

<wiki:comment>
  In ldapadmin/lib/ create the file group.rb:
</wiki:comment>
同様に、ldapadmin/objects/group.rb を作成します。

{{{
class Group < ActiveLdap::Base
  ldap_mapping :dn_attribute => "cn",
               :classes => ['posixGroup']
  # Inspired by ActiveRecord, this tells ActiveLDAP that the
  # LDAP entry has a attribute which contains one or more of
  # some class |:class_name| where the attributes name is
  # |:local_key|. This means that it will call
  # :class_name.new(value_of(:local_key)) to create the objects.
  has_many :members, :class => "User", :wrap => "memberUid"
  has_many :primary_members, :class_name => 'User',
           :foreign_key => 'gidNumber',
           :primary_key => 'gidNumber'
end
}}}

<wiki:comment>
  Now, we can write some small scripts to do simple management tasks.
</wiki:comment>
これでシンプルな管理タスクのためのスクリプトを書けるようになりました。

<wiki:comment>
  Creating LDAP entries
</wiki:comment>

=== LDAP エントリの作成 ===

<wiki:comment>
  Now let's create a really dumb script for adding users -
  ldapadmin/useradd:
</wiki:comment>
早速ユーザを追加するための ldapadmin/useradd スクリプトを作成しましょう。

<wiki:comment>
  #!/usr/bin/ruby -W0

  require 'active_ldap'
  require 'lib/user'
  require 'lib/group'
  require 'password'

  argv, opts, options = ActiveLdap::Command.parse_options do |opts, options|
    opts.banner += " USER_NAME CN UID"
  end

  if argv.size == 3
    name, cn, uid = argv
  else
    $stderr.puts opts
    exit 1
  end

  pwb = Proc.new do |user|
    ActiveLdap::Command.read_password("[#{user}] Password: ")
  end

  ActiveLdap::Base.setup_connection(:password_block => pwb,
                                        :allow_anonymous => false)

  if User.exists?(name)
    $stderr.puts("User #{name} already exists.")
    exit 1
  end

  user = User.new(name)
  user.add_class('shadowAccount')
  user.cn = cn
  user.uid_number = uid
  user.gid_number = uid
  user.home_directory = "/home/#{name}"
  user.sn = "somesn"
  unless user.save
    puts "failed"
    puts user.errors.full_messages
    exit 1
  end
</wiki:comment>
{{{
  #!/usr/bin/ruby -W0

  base = File.expand_path(File.join(File.dirname(__FILE__), ".."))
  $LOAD_PATH << File.join(base, "lib")
  $LOAD_PATH << File.join(base, "examples")

  require 'active_ldap'
  require 'objects/user'
  require 'objects/group'

  argv, opts, options = ActiveLdap::Command.parse_options do |opts, options|
    opts.banner += " USER_NAME CN UID"
  end

  if argv.size == 3
    name, cn, uid = argv
  else
    $stderr.puts opts
    exit 1
  end

  pwb = Proc.new do |user|
    ActiveLdap::Command.read_password("[#{user}] Password: ")
  end

  ActiveLdap::Base.setup_connection(:password_block => pwb,
                                    :allow_anonymous => false)

  if User.exists?(name)
    $stderr.puts("User #{name} already exists.")
    exit 1
  end

  user = User.new(name)
  user.add_class('shadowAccount')
  user.cn = cn
  user.uid_number = uid
  user.gid_number = uid
  user.home_directory = "/home/#{name}"
  user.sn = "somesn"
  unless user.save
    puts "failed"
    puts user.errors.full_messages
    exit 1
  end
}}}

<wiki:comment>
  Managing LDAP entries
</wiki:comment>
=== LDAP エントリの管理 ===

<wiki:comment>
  Now let's create another dumb script for modifying users -
  ldapadmin/usermod:
</wiki:comment>
次に、ユーザの属性変更スクリプト ldapadmin/usermod を作成します。

<wiki:comment>
  #!/usr/bin/ruby -W0

  require 'active_ldap'
  require 'lib/user'
  require 'lib/group'

  argv, opts, options = ActiveLdap::Command.parse_options do |opts, options|
    opts.banner += " USER_NAME CN UID"
  end

  if argv.size == 3
    name, cn, uid = argv
  else
    $stderr.puts opts
    exit 1
  end

  pwb = Proc.new do |user|
    ActiveLdap::Command.read_password("[#{user}] Password: ")
  end

  ActiveLdap::Base.setup_connection(:password_block => pwb,
                                        :allow_anonymous => false)

  unless User.exists?(name)
    $stderr.puts("User #{name} doesn't exist.")
    exit 1
  end

  user = User.find(name)
  user.cn = cn
  user.uid_number = uid
  user.gid_number = uid
  unless user.save
    puts "failed"
    puts user.errors.full_messages
    exit 1
  end
</wiki:comment>
{{{
#!/usr/bin/ruby -W0

base = File.expand_path(File.join(File.dirname(__FILE__), ".."))
$LOAD_PATH << File.join(base, "lib")
$LOAD_PATH << File.join(base, "examples")

require 'active_ldap'
require 'objects/user'
require 'objects/group'

argv, opts, options = ActiveLdap::Command.parse_options do |opts, options|
  opts.banner += " USER_NAME CN UID"
end

if argv.size == 3
  name, cn, uid = argv
else
  $stderr.puts opts
  exit 1
end

pwb = Proc.new do |user|
  ActiveLdap::Command.read_password("[#{user}] Password: ")
end

ActiveLdap::Base.setup_connection(:password_block => pwb,
                                  :allow_anonymous => false)

unless User.exists?(name)
  $stderr.puts("User #{name} doesn't exist.")
  exit 1
end

user = User.find(name)
user.cn = cn
user.uid_number = uid
user.gid_number = uid
unless user.save
  puts "failed"
  puts user.errors.full_messages
  exit 1
end
}}}

<wiki:comment>
  Removing LDAP entries
</wiki:comment>
=== LDAP エントリの削除 ===

<wiki:comment>
  And finally, a dumb script for removing user - ldapadmin/userdel:
</wiki:comment>
最後に、ユーザ削除のためのスクリプト ldapadmin/userdel を作成します。

<wiki:comment>
  #!/usr/bin/ruby -W0

  require 'active_ldap'
  require 'lib/user'
  require 'lib/group'

  argv, opts, options = ActiveLdap::Command.parse_options do |opts, options|
    opts.banner += " USER_NAME"
  end

  if argv.size == 1
    name = argv.shift
  else
    $stderr.puts opts
    exit 1
  end

  pwb = Proc.new do |user|
    ActiveLdap::Command.read_password("[#{user}] Password: ")
  end

  ActiveLdap::Base.setup_connection(:password_block => pwb,
                                        :allow_anonymous => false)

  unless User.exists?(name)
    $stderr.puts("User #{name} doesn't exist.")
    exit 1
  end

  User.destroy(name)
</wiki:comment>
{{{
#!/usr/bin/ruby -W0

base = File.expand_path(File.join(File.dirname(__FILE__), ".."))
$LOAD_PATH << File.join(base, "lib")
$LOAD_PATH << File.join(base, "examples")

require 'active_ldap'
require 'objects/user'
require 'objects/group'

argv, opts, options = ActiveLdap::Command.parse_options do |opts, options|
  opts.banner += " USER_NAME"
end

if argv.size == 1
  name = argv.shift
else
  $stderr.puts opts
  exit 1
end

pwb = Proc.new do |user|
  ActiveLdap::Command.read_password("[#{user}] Password: ")
end

ActiveLdap::Base.setup_connection(:password_block => pwb,
                                  :allow_anonymous => false)

unless User.exists?(name)
  $stderr.puts("User #{name} doesn't exist.")
  exit 1
end

User.destroy(name)
}}}

<wiki:comment>
  Advanced Topics
</wiki:comment>
== 高度な話題 ==

<wiki:comment>
  Below are some situation tips and tricks to get the most out of
  ActiveLdap.
</wiki:comment>
以降では、ActiveLdap を最大限に生かすために、さまざまなシチュエーションで役
立つテクニックを紹介していきます。

<wiki:comment>
  Binary data and other subtypes
</wiki:comment>
=== バイナリデータとサブタイプ ===

<wiki:comment>
  Sometimes, you may want to store attributes with language specifiers, or
  perhaps in binary form. This is (finally!) fully supported. To do so,
  follow the examples below:
</wiki:comment>
しばしば、あなたは属性に言語指定子を指定して値を格納したくなるでしょう。それ
にバイナリデータ形式で投入したいかもしれません。これは十分にサポートされてい
ます。例を見てみましょう。

{{{
  # 新規ユーザの作成
  irb> user = User.new('drewry')
  => ...
  # cn をサーバデフォルト（この場合は英語）でエントリに追加
  irb> user.cn = [ 'wad', {'lang-en' => ['wad', 'Will Drewry']} ]
  => ...
  irb> user.cn
  => ["wad", {"lang-en-us" => ["wad", "Will Drewry"]}]
  # X.509 証明書をバイナリ形式で追加（objectClass の整合性は解決しているものとします）
  irb> user.user_certificate = File.read('example.der')
  => ...
  # 保存
  irb> user.save
}}}

<wiki:comment>
  So that's a lot to take in. Here's what is going on. I just set the LDAP
  object's cn to "wad" and cn:lang-en-us to ["wad", "Will Drewry"]. Anytime a
  LDAP subtype is required, you must encapsulate the data in a Hash.
</wiki:comment>

この例には見るべき点が多くあります。順番に見てみましょう。例では、cn に"wad"
と cn;lang-en-us に ["wad", "Will Drewry"] を追加しています。LDAP属性のサブ
タイプが必要とされるとき、それらのデータは Hash で包む必要があります。

<wiki:comment>
  But wait a minute, I just read in a binary certificate without wrapping it up.
  So any binary attribute _that requires ;binary subtyping_ will automagically
  get wrapped in {'binary’ => value} if you don't do it. This keeps your writes
  from breaking, and my code from crying. For correctness, I could have easily
  done the following:
</wiki:comment>
一方で、上記の例では Hash に包まずに X.509 証明書を格納しました。バイナリデータ
を格納するいくつかのの属性は ;binary サブタイプが必要です。これらの属性に対して
は、プログラマがそうしなくても、自動で {'binary' => value} の Hash で包まれます。
これはコーディングの助けになりますが、正確性のために明示的に Hash で包むことも可
能です。

{{{
  irb>  user.user_certificate = {'binary' => File.read('example.der')}
}}}

<wiki:comment>
  You should note that some binary data does not use the binary subtype all the
  time. One example is jpegPhoto. You can use it as jpegPhoto;binary or just as
  jpegPhoto. Since the schema dictates that it is a binary value, ActiveLdap
  will write it as binary, but the subtype will not be automatically appended as
  above. The use of the subtype on attributes like jpegPhoto is ultimately
  decided by the LDAP site policy and not by any programmatic means.
</wiki:comment>
バイナリデータを格納する場合であっても、必ずしも ;binary サブタイプを利用する訳
ではないことに注意してください。例としては jpegPhoto があります。あなたは
jpegPhoto;binaryか jpegPhoto を利用することができます。スキーマがバイナリ値だと
指示するので ActiveLdap はバイナリ値として書き込むでしょうが、サブタイプは自動的
には付与されません。jpegPhoto のような属性にサブタイプを利用するかどうかは、LDAP
のサイトポリシーによって決められることであって、プログラムが自動で判断できるもの
ではありません。（訳注：userCertificate 属性については、RFC上で ;binary サブタイ
プを利用するよう指示されているため、自動的に ;binary 属性を付与できる一方、
jpegPhoto についてそのような言及が RFC 上にないために、そのような対応を自動的に
行うことは難しい、ということのようです）

<wiki:comment>
  The only subtypes defined in LDAPv3 are lang-* and binary. These can be
  nested though:
</wiki:comment>
LDAPv3 で唯一定義されているサブタイプが lang-* と binary の組み合わせです。
これらは以下のように Hash をネストさせることで実現できます。

{{{
 irb> user.cn = [{'lang-ja' => {'binary' => 'some Japanese'}}]
}}}

<wiki:comment>
  As I understand it, OpenLDAP does not support nested subtypes, but some
  documentation I've read suggests that Netscape's LDAP server does. I only have
  access to OpenLDAP. If anyone tests this out, please let me know how it goes!
</wiki:comment>
ネストされたサブタイプは OpenLDAP でサポートされていません。ですが、いくつかの文
書を確認したところ、ネットスケープの LDAP サーバは対応しているようです。私がアク
セスしたのは OpenLDAP のみなので、どなたかこの機能をテストしたなら、どのように動
作したかを連絡してもらえると助かります。

<wiki:comment>
  And that pretty much wraps up this section.
</wiki:comment>
このセクションの他の項目についても同様です。どのように動作したか連絡もらえると助
かります。

<wiki:comment>
  Further integration with your environment aka namespacing
</wiki:comment>

=== 環境とのさらなる統合 - 別名 名前空間の構築 ===

<wiki:comment>
  If you want this to cleanly integrate into your system-wide Ruby include path,
  you should put your extension classes inside a custom module.
</wiki:comment>
ActiveLdap を Ruby のインクルードパスに統合したいなら、拡張クラスをカスタムモジ
ュールの中に統合するとよいでしょう。

<wiki:comment>
  Example:
</wiki:comment>
例：

==== ./myldap.rb: ====
{{{
require 'active_ldap'
require 'myldap/user'
require 'myldap/group'
module MyLDAP
end
}}}

==== ./myldap/user.rb: ====
{{{
module MyLDAP
  class User < ActiveLdap::Base
    ldap_mapping :dn_attribute => 'uid', :prefix => 'ou=People', :classes => ['top', 'account', 'posixAccount']
    belongs_to :groups, :class_name => 'MyLDAP::Group', :many => 'memberUid'
  end
end
}}}

==== ./myldap/group.rb: ====
{{{
module MyLDAP
  class Group < ActiveLdap::Base
    ldap_mapping :classes => ['top', 'posixGroup'], :prefix => 'ou=Group'
    has_many :members, :class_name => 'MyLDAP::User', :wrap => 'memberUid'
    has_many :primary_members, :class_name => 'MyLDAP::User', :wrap => 'gidNumber', :primary_key => 'gidNumber'
  end
end
}}}

<wiki:comment>
  Now in your local applications, you can call
</wiki:comment>
こうすれば、あなたのアプリケーションでは以下のように呼び出すことができます。

{{{
require 'myldap'

MyLDAP::Group.new('foo')
...
}}}

<wiki:comment>
  and everything should work well.
</wiki:comment>
すべてのクラスは正しく動作するでしょう。

<wiki:comment>
  force array results for single values
</wiki:comment>

=== 単一内容の属性に対する getter アクセスであっても、配列で返すようにする ===

<wiki:comment>
  Even though ActiveLdap attempts to maintain programmatic ease by returning
  Array values only. By specifying 'true’ as an argument to any attribute
  method you will get back a Array if it is single value. Here's an example:
</wiki:comment>
属性メソッドの引数に true を渡すことで、その属性の中身が単一の内容であっても配列
で返すように挙動を変更することができます。

{{{
  irb> user = User.new('drewry')
  => ...
  irb> user.cn(true)
  => ["Will Drewry"]
}}}

<wiki:comment>
  Dynamic attribute crawling
</wiki:comment>
=== 動的な属性のクローリング ===

<wiki:comment>
  If you use tab completion in irb, you'll notice that you /can/ tab complete
  the dynamic attribute methods. You can still see which methods are for
  attributes using Base#attribute_names:
</wiki:comment>
IRBでタブ補完機能を有効にしている場合、属性アクセサメソッドをタブ補完で呼び出す
ことができます。また、Base#attribute_names メソッドを利用すれば属性アクセサメソ
ッドの一覧を得ることが可能です。

{{{
  irb> d = Group.new('develop')
  => ...
  irb> d.attribute_names
  => ["gidNumber", "cn", "memberUid", "commonName", "description", "userPassword", "objectClass"]
}}}

<wiki:comment>
  Juggling multiple LDAP connections
</wiki:comment>
=== 複数の LDAP 接続の切り替え ===

<wiki:comment>
  In the same vein as the last tip, you can use multiple LDAP connections by per
  class as follows:
</wiki:comment>
最後に、クラスごとに別々の LDAP コネクションを利用するには、以下のようにしてくだ
さい。

{{{
  irb> anon_class = Class.new(Base)
  => ...
  irb> anon_class.setup_connection
  => ...
  irb> auth_class = Class.new(Base)
  => ...
  irb> auth_class.setup_connection(:password_block => lambda{'mypass'})
  => ...
}}}

<wiki:comment>
  This can be useful for doing authentication tests and other such tricks.
</wiki:comment>
これは認証のテストなどに有効です。

<wiki:comment>
  :try_sasl
</wiki:comment>
=== :try_sasl ===

<wiki:comment>
  If you have the Ruby/LDAP package with the SASL/GSSAPI patch from Ian
  MacDonald's web site, you can use Kerberos to bind to your LDAP server. By
  default, :try_sasl is false.
</wiki:comment>
:try_sasl を利用することによって LDAP サーバとのバインドに Kerberos を利用するこ
とができます。

<wiki:comment>
  Also note that you must be using OpenLDAP 2.1.29 or higher to use SASL/GSSAPI
  due to some bugs in older versions of OpenLDAP.
</wiki:comment>
またこの場合、OpenLDAP 2.1.29 かそれ以上が必要です。それ以前のバージョンには多数
のバグが残っています。

<wiki:comment>
  Don't be afraid! [Internals]
</wiki:comment>
=== こわがらないでください！ ===

<wiki:comment>
  Don't be afraid to add more methods to the extensions classes and to
  experiment. That's exactly how I ended up with this package. If you come up
  with something cool, please share it!
</wiki:comment>
更にメソッドを追加することや、拡張クラスを定義することや、実験することを恐れない
でください。私にとってこのパッケージの作成は一区切りつきましたが、もしクールな何
かをあなたが見つけたなら、それを共有させてください！

<wiki:comment>
  The internal structure of ActiveLdap::Base, and thus all its subclasses, is
  still in flux. I've tried to minimize the changes to the overall API, but the
  internals are still rough around the edges.
</wiki:comment>
ActiveLdap::Base やそのサブクラスの構造は、まだ不安定です。外側の API については
最小の変化で済ませてきましたが、内部についてはまだ荒削りです。

<wiki:comment>
  Where's ldap_mapping data stored? How can I get to it?
</wiki:comment>
=== ldap_mapping データはどこに保存されていますか？ それらはどうやって取得しますか？ ===

<wiki:comment>
  When you call ldap_mapping, it overwrites several class methods inherited from
  Base:
</wiki:comment>
ldap_mapping をコールしたとき、ActiveLdap::Base のいくつかのクラスメソッドがオー
バーライドされます。以下のメソッドです。

  * Base.base()
  * Base.required_classes()
  * Base.dn_attribute()

<wiki:comment>
  You can access these from custom class methods by calling MyClass.base(), or
  whatever. There are predefined instance methods for getting to these from any
  new instance methods you define:
</wiki:comment>
これらのクラスメソッドに MyClass.base() のようにアクセスすることができます。イン
スタンスからもこれらの情報を知るために、拡張クラスのインスタンスメソッドに以下の
ような定義済みメソッドが用意されています。

 * Base#base()
 * Base#required_classes()
 * Base#dn_attribute()

<wiki:comment>
  What else?
</wiki:comment>
=== その他の話題 ===

<wiki:comment>
  Well if you want to use the LDAP connection for anything, I'd suggest still
  calling Base.connection to get it. There really aren't many other internals
  that need to be worried about. You could get the LDAP schema with Base.schema.
</wiki:comment>
もしあなたが何らかの理由で LDAP コネクションを扱いたいなら、それを取得するために
ActiveLdap::Base.connection メソッドをコールすることを今のところ提案します。他の
内部機構で接続を扱うものは少ないです。スキーマの情報については
ActiveLdap::Base.schema メソッドにより取得できます。

<wiki:comment>
  The only other useful tricks are dereferencing and accessing the stored data.
  Since LDAP attributes can have multiple names, e.g. cn or commonName, any
  methods you write might need to figure it out. I'd suggest just calling
  self[attribname] to get the value, but if that's not good enough, you can call
  look up the stored name by to_real_attribute_name as follows:
</wiki:comment>
他の便利な唯一の手法は、格納されたデータをデリファレンスしてアクセスすることです
（訳注：たぶん、Perl の derefence と同じ意味で言っていると思われる）。

従来、LDAP属性はcn / commonName のように複数の名前を持つことができ、あなたが書く
どのメソッドもそれを考慮にいれておかなければならないかもしれません（訳注：cn を
デリファレンスしても、commonName をデリファレンスしても同じ参照先オブジェクトを
得ることがあるから注意せよ、の意だと思われます）。

デリファレンスして値を得るには self['属性名'] とすることを提案しますが、上記を考
慮すると十分ではありません。実際に格納されている属性の一意な名前を得るためには
to_real_attribute_name プライベートメソッドを利用することができます。

{{{
  >> u = User.find :first
  >> u.instance_eval do
  ?>   to_real_attribute_name 'commonName'
  >> end
  => "cn"
}}}

<wiki:comment>
  This tells you the name the attribute is stored in behind the scenes (@data).
  Again, self[attribname] should be enough for most extensions, but if not, it's
  probably safe to dabble here.
</wiki:comment>
このメソッドは背後（@data）で属性データが格納されている名前をあなたに教えます。
再び、self[属性名] はほとんどの拡張に対して十分でなくてはなりませんが、そうでな
くても、たぶんここでは問題にならないでしょう。

<wiki:comment>
  Also, if you like to look up all aliases for an attribute, you can call the
  following:
</wiki:comment>
また例えば、ユーザクラスの属性名のエイリアスを見つけるためには以下のようにすると
よいでしょう。

<wiki:comment>
  *obsolete
 irb> schema.attribute_aliases('cn')
 => ['cn','commonName']
</wiki:comment>
{{{
  irb> User.schema.attribute_type 'cn', 'NAME'
  => ['cn','commonName']
}}}

<wiki:comment>
  This is discovered automagically from the LDAP server's schema.
</wiki:comment>
これはLDAP サーバのスキーマから自動的に発見します。

<wiki:comment>
  Limitations
</wiki:comment>
== 制限 ==

<wiki:comment>
  Speed
</wiki:comment>
=== 実行速度 ===

<wiki:comment>
  Currently, ActiveLdap could be faster. I have some recursive type checking
  going on which slows object creation down, and I'm sure there are many, many
  other places optimizations can be done. Feel free to send patches, or just
  hang in there until I can optimize away the slowness.  
</wiki:comment>
今のところ、ActiveLdap はまだ高速にできます。いくつかの再帰的な型チェックをオブ
ジェクト作成時に行っており、それらがオブジェクトの生成速度を落としています。ま
た、他のところでも多数の最適化が可能であることも認識しています。最適化できていな
い部分については私が最適化できるようになるまで我慢してもらうか、または気軽にパッ
チを送ってください。

<wiki:comment>
  Feedback
</wiki:comment>
== フィードバック ==

<wiki:comment>
  Any and all feedback and patches are welcome. I am very excited about this
  package, and I'd like to see it prove helpful to more people than just myself.
</wiki:comment>
どんなものでも、またすべてのフィードバックやパッチを歓迎します。私はこのパッケー
ジについて興奮しています。また、私以上に、人々の助けになることを見たいと思ってい
ます。